//割と忘れそうなのでGLSLについてもメモしておく

講義で出てきた順なので箇条書きになることは否めない

//versionについて
数字に規則性もあるが今回は410しか使わない,とにかく一番上に忘れずにこう書こう

#version 410

//in/out修飾子について
in はこのシェーダへの入力が格納される
out はこのシェーダで設定した値を次のステージに送る

vertとflagしか設定しない今回は

vertexShaderの in修飾子 = VAOで設定した頂点のデータになるのだ


//layout修飾子について
layout(qualifier1 = value, qualifier2 = value, …)←構文らしい

入出力先や属性を指定するために使われる
in/outと組み合わせれば入出力先


vec3/vec4型について

GLSL型で定義されてるvec型.
glmと同じように動く.


//GLSLにおいてのmein()関数
C言語のノリで構わない
各シェーダーで行う処理はmainの中で行う


//sampler2D 変数について
テクスチャを使用するときに使う

uniform宣言と関数の引数でしか使えない

主にtexture(sampler2D変数,テクスチャ座標)関数で使う


サンプラー変数をアプリケーション側から取得する場合
普通のuniformとほとんど変わらないが
テクスチャデータを送信する際.
glUniformi(locationid,テクスチャイメージユニットの番号);
になる
その後テクスチャイメージユニットにテクスチャを割り当て
描画するといった段取りとなる



InterfaceBlock または uniformBlock
uniform変数の構造体のようなものなのだが
送信方法が相当難しくなる
uniform変数
アプリ側で位置を取得
専用uniform変数でデータの送信.
だったのに対して

uniformBlockは
uniformBlockの位置の取得
uniformBlockの位置とバインディングポイントを関連付ける

uboを作成
uboとバインディングポイントを関連付ける
uboを通してバインディングポイントにデータを送信する.

こんな感じになる

テクスチャのイメージユニットみたいに一個バッファを噛ますような感じ
これによって,上手く行かないことが続出するのだ,



//dot()関数　そのまんま内積 float dot(Vec3 A,Vec3 B)戻り値 A ・ B

//clamp()関数 第一引数の値をA,Bの間に収める float clamp(float f,float A,float B)<<戻り値fがA以下ならA,B以上ならBを代入して返す

//normalize()関数 引数を単位ベクトルに変換する